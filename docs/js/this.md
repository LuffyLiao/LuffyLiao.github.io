---
title: 面试题
date: 2021-06-06 22:29:06
sidebar: 'auto'
categories: 
 - 日常笔记
---
### this到底指向谁
**谁调用就指向谁**
- 严格模式下，函数内的this会被绑定到undefined上，非严格模式则会被绑定到全局对象window/global上
- 一般使用new 构造函数时，构造函数内的this会被绑定到新创建的对象上
- 一般通过call/bind/apply方法显式调用时，函数内的this会被绑定到指定的参数对象上
- 箭头函数的this是由外层作用域决定

### js代码执行的两个阶段
- 代码预编译阶段
- 代码执行阶段

JavaScript是解释型语言，编译一行，执行一行。但是在代码执行前，JavaScript引擎会做一些预准备工作。

1. 进行变量声明
2. 对变量声明进行提升，但是值为undefined
3. 函数声明提升
代码执行的整个过程就是一条生产流水线。第一道工序是在预编译阶段创建变量对象VO(Veriable Object)，此时只是创建，而未进行赋值。到了下一道工序代码执行阶段，变量对象会转为激活对象AO(Active Object)，既完成VO到AO的转换，此时作用域会被确定。

### 内存管理

1. 基本概念
- 栈：由操作系统自动分配，存放的是原始数据类型
- 堆：由开发者分配释放，这部分要考虑垃圾回收的问题，一般存放的是引用类型的地址
2. 垃圾回收
- 引用计数 计算引用的次数
- 标记清除 使用了一次就标记一次

### 输入url 全过程
1. 解析url，根据dns系统进行ip查找
    - 先查找host文件是否有设置，有的话就会把对应的ip映射返回
    - 如果host没有，则去查找本地dns服务器有没有缓存，有则返回
    - 根dns服务器上查找
2. tcp三次握手
    - 主机A发送请求建立连接
    - 主机B收到，向A发送确认号
    - 主机A收到，检查确认号，主机A再次发送确认号，主机B收到确认，建立连接
3. 请求html文件，如果文件在缓存，则直接返回，没有就从后台拿
    - 构建dom树，从上到下解析html文档生成dom节点
    - 构建cssom树，加载解析样式生成cssom树
    - 执行JavaScript
    - 构建渲染树，根据dom树和cssom树，生成渲染树
    - 布局，根据渲染树将节点树的每一个节点布局在屏幕上的正确位置
    - 绘制，遍历渲染树绘制所有节点
### http https http2.0
1. http：超文本传输协议
    - 请求报文：请求行（method version）、请求头、请求数据、url、policy
    - 响应报文：状态行 keep-alive 、user-agent
2. tcp/udp
    - tcp：面向连接的协议，类似打电话，需要确认身份
    - udp：面向无连接的协议，类似广播
3. https
    - https就是从http加上加密处理 + 认证 + 完整性保护
    - 区别： 加密 + 安全性
4. http2
    - 多路复用：即共享连接，每个request对应一个id，共享机制，这样一个连接上可以有多个request，接收方根据request的id用作区分
    - 二进制分帧
5. 状态码 
    - 2XX：成功 200
    - 3XX：重定向 302：临时重定向 301：永久重定向
    - 4XX：客户端错误 404 not found
    - 5XX：服务端错误 500

### webpack
1. webpack的作用：
    - 模块打包，将不同模块的文件打包整合在一起
    - 编译兼容，编译转换.less,.vue,.jsx,es6这类在浏览器无法识别的文件
    - 能力扩展，比如按需加载，代码压缩
2. 模块打包的原理
    - 读取webpack配置参数
    - 启动webpack，创建compiler对象并解析项目
    - 从入口文件entry解析，找到依赖模块，递归遍历分析，形成依赖关系树
    - 对不同文件类型的依赖模块文件使用对应的loader进行编译，转成js文件
    - 最终生成的是一个IIFE自执行函数
3. sourceMap
sourceMap是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中debug问题会带来非常糟糕的体验，sourceMap可以帮助我们快速定位到源代码的位置，提高我们的开发效率。一般在开发环境配置，线上关闭。
4. Loader: 对非js文件的转换，所以思路应该是通过正则匹配到对应的文件，然后进行转换，最终返回一个js的字符串。目前生态已经可以满足日常需求，想不出还有什么场景需要自己去写loader。
5. Plugin: 写过，举一个简单的路径替换的例子
    - 在plug目录下创建一个js文件
    - 因为需要访问compiler对象，所以plug中必须是一个函数或者一个包含apply方法的对象
    - 遍历所有的资源文件，匹配到符合条件的文件，进行正则替换
    - webpack配置new CssPath
### 数据类型的判断
1. typeof：只能判断原始数据类型，对引用类型的话不准确
2. constructor：查看目标的构造函数，但是null和undefined 会报错，而且这个可以人为手动修改，不准确
3. instanceof：a instanceof A，a是否为A的实例，即a的原型链上是否存在A的构造函数
4. Object.prototype.toString.call()：万能的方法，任何Object原型都有toString方法

### 原型链
原型指的就是一个对象，实例继承那个对象的属性。在原型上定义的属性，通过继承，实例也有这个属性。
原型链就是一个过程，原型是原型链这个过程中的一个单位，贯穿整个原型链，比如一个new一个Object，由他实例化的fn的__proto__ -> constructor 指向Object，而Object

### vue 和 react的区别 ，都是MVVM框架，数据更新视图
1. 监听数据变化的实现原理不同
    - vue : Object.property getter setter 劫持数据，能精确知道数据的变化，使用的是可变数据
    - react: React 默认是通过比较引用的方式进行的，更强调数据的不可变性
2. 数据流不同
    - vue: parent -> child <-> dom，
    - react: parent -> child -> dom，单向数据流
3. 混入方式
    - vue: mixins
    - react: HoC(高阶组件)：一个函数接受一个组件作为参数，经过加工，返回一个新组件。
4. 模板渲染方式：
    - vue: html
    - react: jsx渲染模板，功能强大，灵活性强
5. anuglar: MVC框架

### react hooks
react都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。
hooks 本质就是一类特殊的函数，他们可以为你的函数型组件注入一些特殊功能，不用再写很难维护的class。让function一统江湖